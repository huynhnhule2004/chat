# GROUP CHAT E2EE ARCHITECTURE GUIDE
## Password Protected + Session Key Distribution

---

## üéØ OVERVIEW

This document explains the complete architecture for implementing **Group Chat with Password Protection and End-to-End Encryption (E2EE)** using a **Shared Session Key** model with **RSA-based key distribution**.

### Key Features
- ‚úÖ **Password Protected Rooms**: Groups can require password to join
- ‚úÖ **E2EE**: Server never sees plaintext messages
- ‚úÖ **Session Key Distribution**: Efficient group encryption (encrypt once, send to many)
- ‚úÖ **Key Rotation**: Kicked members can't decrypt new messages
- ‚úÖ **Scalable**: Supports hundreds of members per group

---

## üîê SECURITY MODEL: The Lock & Dictionary Analogy

Understanding group chat E2EE through a real-world metaphor:

### 1. The Outer Door Lock (Password)
- **What**: Room password stored as bcrypt hash on server
- **Purpose**: Access control - prevents unauthorized users from joining
- **Where**: Server validates with `bcrypt.compare()`
- **Analogy**: Like a bouncer checking IDs at a club entrance

### 2. The Secret Dictionary (Session Key)
- **What**: 256-bit AES key used to encrypt group messages
- **Purpose**: E2EE encryption - server can't read messages even if user passes password check
- **Where**: Generated by admin, encrypted differently for each member
- **Analogy**: Once inside the club, everyone speaks a secret language

### 3. The Personal Safe (Encrypted Session Key)
- **What**: Session Key encrypted with each member's RSA public key
- **Purpose**: Secure distribution - each member gets their own encrypted copy
- **Where**: Stored in `RoomMember.encryptedSessionKey`
- **Analogy**: Each person gets the dictionary locked in a safe only they can open

### 4. Burning the Old Dictionary (Key Rotation)
- **What**: Generate new Session Key after kicking a member
- **Purpose**: Forward secrecy - kicked member can't decrypt new messages
- **Where**: Admin rotates key, re-encrypts for remaining members
- **Analogy**: When someone is kicked out, change the secret language

---

## üìä DATABASE ARCHITECTURE

### Backend (MongoDB)

#### **1. Room Schema**
```javascript
{
  _id: ObjectId,
  name: "My Group",
  type: "group",  // or "channel"
  avatar: "https://...",
  description: "Group description",
  
  // Admin
  ownerId: ObjectId (ref: User),
  
  // Password Protection
  passwordHash: "$2a$10$...",  // bcrypt hash, null = public room
  isPasswordProtected: true,
  
  // Members
  members: [ObjectId, ObjectId, ...],  // User IDs
  memberCount: 42,
  
  // E2EE Key Management
  sessionKeyVersion: 3,  // Increments on key rotation
  
  // Settings
  settings: {
    allowMembersToInvite: true,
    allowMembersToAddMembers: false,
    maxMembers: 500
  },
  
  // Timestamps
  createdAt: Date,
  updatedAt: Date,
  lastMessageAt: Date
}
```

#### **2. RoomMember Schema** (Critical for E2EE)
```javascript
{
  _id: ObjectId,
  roomId: ObjectId (ref: Room),
  userId: ObjectId (ref: User),
  
  // E2EE: Each member's encrypted copy of SessionKey
  encryptedSessionKey: "base64_encrypted_data",  // RSA-OAEP encrypted
  sessionKeyVersion: 3,  // Must match Room.sessionKeyVersion
  
  // Role & Permissions
  role: "owner" | "admin" | "member",
  
  // Status
  joinedAt: Date,
  isActive: true,  // false if kicked/left
  leftAt: Date,
  
  // Notifications
  unreadCount: 5,
  isMuted: false,
  mutedUntil: Date
}
```

### Frontend (SQLite)

#### **1. rooms table**
```sql
CREATE TABLE rooms (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  avatar TEXT,
  description TEXT,
  type TEXT NOT NULL DEFAULT 'group',
  owner_id TEXT NOT NULL,
  is_password_protected INTEGER NOT NULL DEFAULT 0,
  member_count INTEGER NOT NULL DEFAULT 0,
  session_key_version INTEGER NOT NULL DEFAULT 1,
  created_at TEXT NOT NULL,
  last_message_at TEXT
);
```

#### **2. room_members table**
```sql
CREATE TABLE room_members (
  id TEXT PRIMARY KEY,
  room_id TEXT NOT NULL,
  user_id TEXT NOT NULL,
  encrypted_session_key TEXT NOT NULL,  -- Base64 RSA-encrypted
  session_key_version INTEGER NOT NULL DEFAULT 1,
  role TEXT NOT NULL DEFAULT 'member',
  joined_at TEXT NOT NULL,
  unread_count INTEGER NOT NULL DEFAULT 0,
  is_muted INTEGER NOT NULL DEFAULT 0,
  is_active INTEGER NOT NULL DEFAULT 1,
  UNIQUE(room_id, user_id)
);
```

#### **3. messages table (extended)**
```sql
CREATE TABLE messages (
  id TEXT PRIMARY KEY,
  sender_id TEXT NOT NULL,
  receiver_id TEXT,           -- NULL for group messages
  room_id TEXT,                -- NULL for 1-1 messages
  content TEXT NOT NULL,       -- Encrypted with SessionKey
  iv TEXT,                     -- AES-GCM initialization vector
  auth_tag TEXT,               -- AES-GCM authentication tag
  message_type TEXT NOT NULL,
  timestamp INTEGER NOT NULL
);
```

---

## üîÑ KEY DISTRIBUTION FLOWS

### Flow 1: Create Group

**Admin Side (Flutter)**
```dart
// 1. Admin generates Session Key
final sessionKey = await GroupKeyService.generateSessionKey(); // 256-bit random

// 2. Admin fetches public keys of initial members
final members = ['user1_id', 'user2_id', 'user3_id'];
final publicKeys = await fetchPublicKeys(members);

// 3. Admin encrypts Session Key for each member
List<EncryptedKey> encryptedKeys = [];
for (var member in members) {
  final encryptedKey = await GroupKeyService.encryptSessionKey(
    sessionKey, 
    publicKeys[member]
  );
  encryptedKeys.add(EncryptedKey(userId: member, key: encryptedKey));
}

// 4. Admin sends to server
await api.createGroup({
  name: "My Group",
  password: "secret123",  // Will be bcrypt hashed on server
  initialMembers: members,
  encryptedSessionKeys: encryptedKeys
});

// 5. Admin stores Session Key locally (plaintext in secure storage)
await secureStorage.write(key: 'group_${groupId}_key', value: sessionKey);
```

**Server Side (Node.js)**
```javascript
// 1. Hash password
const passwordHash = await bcrypt.hash(password, 10);

// 2. Create room
const room = new Room({
  name, avatar, ownerId,
  passwordHash,
  isPasswordProtected: true,
  members: [ownerId, ...initialMembers],
  sessionKeyVersion: 1
});
await room.save();

// 3. Store encrypted keys for each member
const roomMemberEntries = encryptedSessionKeys.map(({ userId, encryptedKey }) => ({
  roomId: room._id,
  userId,
  encryptedSessionKey: encryptedKey,  // Already encrypted by client
  sessionKeyVersion: 1,
  role: userId === ownerId ? 'owner' : 'member'
}));
await RoomMember.insertMany(roomMemberEntries);
```

### Flow 2: Join Group

**User Side (Flutter)**
```dart
// 1. User finds group and clicks "Join"
// 2. If password protected, show password dialog
final password = await showPasswordDialog();

// 3. User sends join request
final response = await api.joinGroup(groupId, password);

// 4. Server validates password
//    If valid, returns user's encrypted Session Key
final encryptedKey = response['encryptedSessionKey'];

// 5. User decrypts with their private key
final privateKey = await secureStorage.read('private_key');
final sessionKey = await GroupKeyService.decryptSessionKey(
  encryptedKey, 
  privateKey
);

// 6. Store Session Key locally
await secureStorage.write(key: 'group_${groupId}_key', value: sessionKey);

// 7. User can now decrypt group messages
```

**Server Side (Node.js)**
```javascript
// 1. Validate password
const room = await Room.findById(roomId);
if (room.isPasswordProtected) {
  const isValid = await bcrypt.compare(password, room.passwordHash);
  if (!isValid) {
    return res.status(401).json({ error: 'Incorrect password' });
  }
}

// 2. Add user to room
await room.addMember(userId);

// 3. Create RoomMember entry with encrypted key
//    (Note: Admin must have pre-encrypted the key for this user)
const roomMember = new RoomMember({
  roomId, userId,
  encryptedSessionKey,  // Received from admin
  sessionKeyVersion: room.sessionKeyVersion
});
await roomMember.save();

// 4. Return encrypted key to user
res.json({ 
  encryptedSessionKey: roomMember.encryptedSessionKey 
});
```

### Flow 3: Send Group Message

**Sender Side (Flutter)**
```dart
// 1. Get Session Key from secure storage
final sessionKey = await secureStorage.read('group_${groupId}_key');

// 2. Encrypt message with Session Key (AES-256-GCM)
final encrypted = await CryptoService.encryptWithAESGCM(
  plaintext: "Hello group!",
  key: sessionKey
);

// 3. Send via socket
socket.emit('send_group_message', {
  roomId: groupId,
  content: encrypted.ciphertext,      // Base64 encrypted
  iv: encrypted.iv,                   // Initialization vector
  authTag: encrypted.authTag,         // Authentication tag
  messageType: 'text'
});
```

**Server Side (Node.js)**
```javascript
// Server NEVER sees plaintext - just broadcasts encrypted message
socket.on('send_group_message', async (data) => {
  const { roomId, content, iv, authTag } = data;
  
  // Save encrypted message
  const message = new Message({
    sender: userId,
    roomId,
    content,    // Still encrypted
    iv,
    authTag
  });
  await message.save();
  
  // Broadcast to all members in room
  io.to(roomId).emit('receive_group_message', {
    id: message._id,
    sender: userId,
    roomId,
    content,    // Still encrypted
    iv,
    authTag,
    timestamp: message.timestamp
  });
});
```

**Receiver Side (Flutter)**
```dart
// 1. Receive encrypted message
socket.on('receive_group_message', (data) async {
  // 2. Get Session Key
  final sessionKey = await secureStorage.read('group_${data.roomId}_key');
  
  // 3. Decrypt message
  final plaintext = await CryptoService.decryptWithAESGCM(
    ciphertext: data.content,
    key: sessionKey,
    iv: data.iv,
    authTag: data.authTag
  );
  
  // 4. Display message
  print(plaintext);  // "Hello group!"
});
```

### Flow 4: Kick Member (Key Rotation)

**Critical Security Feature**: Kicked member can't read new messages!

**Admin Side (Flutter)**
```dart
// 1. Admin clicks "Kick user_X"
await kickMember(roomId, userXId);

// 2. Generate NEW Session Key
final newSessionKey = await GroupKeyService.generateSessionKey();

// 3. Get remaining members (excluding kicked user)
final remainingMembers = room.members.where((id) => id != userXId).toList();

// 4. Fetch their public keys
final publicKeys = await fetchPublicKeys(remainingMembers);

// 5. Encrypt NEW Session Key for remaining members
List<EncryptedKey> newEncryptedKeys = [];
for (var memberId in remainingMembers) {
  final encryptedKey = await GroupKeyService.encryptSessionKey(
    newSessionKey, 
    publicKeys[memberId]
  );
  newEncryptedKeys.add(EncryptedKey(userId: memberId, key: encryptedKey));
}

// 6. Send to server
await api.kickMember(roomId, {
  memberIdToKick: userXId,
  newEncryptedSessionKeys: newEncryptedKeys
});

// 7. Update local Session Key
await secureStorage.write(key: 'group_${roomId}_key', value: newSessionKey);
```

**Server Side (Node.js)**
```javascript
// 1. Remove kicked member
await room.removeMember(memberIdToKick);
await RoomMember.removeMember(roomId, memberIdToKick);

// 2. Increment session key version
await room.rotateSessionKey();  // sessionKeyVersion: 2 -> 3

// 3. Update all remaining members with new encrypted keys
for (const { userId, encryptedKey } of newEncryptedSessionKeys) {
  await RoomMember.updateSessionKey(
    roomId, 
    userId, 
    encryptedKey, 
    room.sessionKeyVersion
  );
}

// 4. Notify remaining members (via socket)
io.to(roomId).emit('session_key_rotated', {
  roomId,
  newKeyVersion: room.sessionKeyVersion,
  kickedUserId: memberIdToKick
});
```

**Remaining Member Side (Flutter)**
```dart
// Listen for key rotation event
socket.on('session_key_rotated', (data) async {
  // 1. Fetch new encrypted Session Key from server
  final response = await api.getRoom(data.roomId);
  final newEncryptedKey = response['encryptedSessionKey'];
  
  // 2. Decrypt with private key
  final privateKey = await secureStorage.read('private_key');
  final newSessionKey = await GroupKeyService.decryptSessionKey(
    newEncryptedKey, 
    privateKey
  );
  
  // 3. Update local Session Key
  await secureStorage.write(
    key: 'group_${data.roomId}_key', 
    value: newSessionKey
  );
  
  print('Session key updated! Kicked member can\'t decrypt new messages.');
});
```

**Kicked Member Side**
```dart
// Kicked member still has OLD Session Key
// When they try to decrypt new messages:
try {
  final oldSessionKey = await secureStorage.read('group_${roomId}_key');
  final plaintext = await CryptoService.decryptWithAESGCM(
    ciphertext: newMessage.content,
    key: oldSessionKey,  // OLD KEY
    iv: newMessage.iv,
    authTag: newMessage.authTag
  );
} catch (e) {
  print('Decryption failed! You were kicked.'); // ‚úÖ Security works!
}
```

---

## üõ°Ô∏è SECURITY GUARANTEES

### 1. Password Protection (Server-Side)
- ‚úÖ Passwords stored as bcrypt hash (10 rounds)
- ‚úÖ Server validates password before granting access
- ‚úÖ Plaintext password NEVER stored or logged

### 2. E2EE (Client-Side)
- ‚úÖ Messages encrypted with Session Key (AES-256-GCM)
- ‚úÖ Server only stores encrypted content
- ‚úÖ Server CANNOT decrypt messages (no Session Key)

### 3. Key Distribution (Hybrid Encryption)
- ‚úÖ Session Key encrypted with RSA-2048 public key per member
- ‚úÖ Only member's private key can decrypt their copy
- ‚úÖ Each member gets unique encrypted copy (different ciphertext)

### 4. Forward Secrecy (Key Rotation)
- ‚úÖ Kicked members can't decrypt new messages
- ‚úÖ Old Session Key becomes useless after rotation
- ‚úÖ Remaining members get new encrypted Session Key

### 5. Integrity (AES-GCM Auth Tag)
- ‚úÖ Auth tag prevents tampering with encrypted messages
- ‚úÖ Modified ciphertext fails decryption
- ‚úÖ Protects against MITM attacks

---

## üì° API ENDPOINTS

### **POST /api/groups/create**
Create a new group chat.

**Request:**
```json
{
  "name": "My Group",
  "avatar": "https://...",
  "description": "Group description",
  "password": "secret123",
  "initialMembers": ["user1_id", "user2_id"],
  "encryptedSessionKeys": [
    { "userId": "user1_id", "encryptedKey": "base64_encrypted" },
    { "userId": "user2_id", "encryptedKey": "base64_encrypted" }
  ]
}
```

**Response:**
```json
{
  "message": "Group created successfully",
  "room": {
    "id": "room_id",
    "name": "My Group",
    "memberCount": 3,
    "sessionKeyVersion": 1
  }
}
```

### **POST /api/groups/join**
Join a group (password validation).

**Request:**
```json
{
  "roomId": "room_id",
  "password": "secret123",
  "encryptedSessionKey": "base64_encrypted_for_this_user"
}
```

**Response:**
```json
{
  "message": "Joined successfully",
  "room": {
    "id": "room_id",
    "encryptedSessionKey": "your_encrypted_copy"
  }
}
```

### **POST /api/groups/:roomId/kick**
Kick a member (Admin only).

**Request:**
```json
{
  "memberIdToKick": "user_x_id",
  "newEncryptedSessionKeys": [
    { "userId": "remaining_user_1", "encryptedKey": "new_key" },
    { "userId": "remaining_user_2", "encryptedKey": "new_key" }
  ]
}
```

**Response:**
```json
{
  "message": "Member kicked and key rotated",
  "room": {
    "sessionKeyVersion": 3
  }
}
```

---

## üîå SOCKET EVENTS

### Client ‚Üí Server

#### **join_group**
```javascript
socket.emit('join_group', { roomId: 'room_id' });
```

#### **send_group_message**
```javascript
socket.emit('send_group_message', {
  roomId: 'room_id',
  content: 'base64_encrypted',
  iv: 'base64_iv',
  authTag: 'base64_auth_tag',
  messageType: 'text'
});
```

### Server ‚Üí Client

#### **receive_group_message**
```javascript
socket.on('receive_group_message', (data) => {
  // data: { id, sender, roomId, content, iv, authTag, timestamp }
});
```

#### **session_key_rotated**
```javascript
socket.on('session_key_rotated', (data) => {
  // data: { roomId, newKeyVersion, kickedUserId }
  // Client must fetch new encrypted Session Key
});
```

#### **member_joined**
```javascript
socket.on('member_joined', (data) => {
  // data: { roomId, userId, timestamp }
});
```

---

## üé® FLUTTER UI COMPONENTS

### 1. Create Group Screen
```dart
class CreateGroupScreen extends StatefulWidget {
  @override
  _CreateGroupScreenState createState() => _CreateGroupScreenState();
}

class _CreateGroupScreenState extends State<CreateGroupScreen> {
  final _nameController = TextEditingController();
  bool _isPasswordProtected = false;
  final _passwordController = TextEditingController();
  List<User> _selectedMembers = [];

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('Create Group')),
      body: Column(
        children: [
          // Group name
          TextField(
            controller: _nameController,
            decoration: InputDecoration(labelText: 'Group Name'),
          ),
          
          // Password toggle
          SwitchListTile(
            title: Text('Password Protected'),
            value: _isPasswordProtected,
            onChanged: (val) => setState(() => _isPasswordProtected = val),
          ),
          
          // Password field (conditional)
          if (_isPasswordProtected)
            TextField(
              controller: _passwordController,
              decoration: InputDecoration(labelText: 'Password'),
              obscureText: true,
            ),
          
          // Member selection
          ElevatedButton(
            onPressed: _selectMembers,
            child: Text('Add Members (${_selectedMembers.length})'),
          ),
          
          // Create button
          ElevatedButton(
            onPressed: _createGroup,
            child: Text('Create Group'),
          ),
        ],
      ),
    );
  }
  
  Future<void> _createGroup() async {
    // 1. Generate Session Key
    final sessionKey = await GroupKeyService.generateSessionKey();
    
    // 2. Encrypt for each member
    final encryptedKeys = await GroupKeyService.encryptForMembers(
      sessionKey, 
      _selectedMembers.map((u) => u.id).toList()
    );
    
    // 3. Create group
    await GroupService.createGroup(
      name: _nameController.text,
      password: _isPasswordProtected ? _passwordController.text : null,
      members: _selectedMembers.map((u) => u.id).toList(),
      encryptedKeys: encryptedKeys,
    );
  }
}
```

### 2. Join Group Dialog
```dart
Future<void> showJoinGroupDialog(BuildContext context, Room room) async {
  if (!room.isPasswordProtected) {
    // Public room - join directly
    await GroupService.joinGroup(room.id, null);
    return;
  }
  
  // Password protected - show dialog
  final password = await showDialog<String>(
    context: context,
    builder: (context) {
      final controller = TextEditingController();
      return AlertDialog(
        title: Text('Enter Password'),
        content: TextField(
          controller: controller,
          decoration: InputDecoration(labelText: 'Password'),
          obscureText: true,
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text('Cancel'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, controller.text),
            child: Text('Join'),
          ),
        ],
      );
    },
  );
  
  if (password != null) {
    try {
      await GroupService.joinGroup(room.id, password);
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Joined ${room.name}')),
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Incorrect password')),
      );
    }
  }
}
```

---

## ‚ö° PERFORMANCE CONSIDERATIONS

### Message Encryption Benchmark
- **1-1 Chat (old method)**: Encrypt with recipient's public key
  - RSA-2048: ~50ms per message
  - For 100 members: 5 seconds! ‚ùå
  
- **Group Chat (Session Key)**: Encrypt once with AES-256-GCM
  - AES-256-GCM: ~1ms per message
  - For 100 members: 1ms (server broadcasts) ‚úÖ
  - **50x faster!**

### Key Distribution Overhead
- Session Key encryption (RSA): ~10ms per member
- For 100 members: 1 second (one-time cost) ‚úÖ
- Amortized over thousands of messages: negligible

### Key Rotation Impact
- Kicked 1 member from 100-member group
- Rotate key: 1 second (10ms √ó 99 remaining members)
- Happens rarely (only when kicking members)
- Acceptable tradeoff for security

---

## üß™ TESTING CHECKLIST

### Backend Tests
- [ ] Create group with password ‚Üí Password stored as bcrypt hash
- [ ] Join group with correct password ‚Üí Success
- [ ] Join group with wrong password ‚Üí 401 Unauthorized
- [ ] Kick member ‚Üí Session key version incremented
- [ ] Non-admin tries to kick ‚Üí 403 Forbidden

### E2EE Tests
- [ ] Admin creates group ‚Üí Session Key generated
- [ ] Admin encrypts Session Key for 5 members ‚Üí 5 different ciphertexts
- [ ] Member joins ‚Üí Receives encrypted Session Key
- [ ] Member decrypts Session Key with private key ‚Üí Success
- [ ] Member sends message ‚Üí Encrypted with Session Key
- [ ] Other members decrypt message ‚Üí Same plaintext

### Key Rotation Tests
- [ ] Admin kicks User X ‚Üí New Session Key generated
- [ ] Remaining members receive new encrypted keys
- [ ] User X tries to decrypt new message ‚Üí Fails ‚úÖ
- [ ] Remaining members decrypt new message ‚Üí Success

### UI Tests
- [ ] Create group screen ‚Üí Password toggle works
- [ ] Join group dialog ‚Üí Shows for password-protected rooms
- [ ] Group list ‚Üí Shows all user's groups
- [ ] Group chat screen ‚Üí Messages encrypted/decrypted correctly

---

## üìù IMPLEMENTATION CHECKLIST

### Backend (Node.js + MongoDB)
- [x] Create `Room` model with `passwordHash`, `sessionKeyVersion`
- [x] Create `RoomMember` model with `encryptedSessionKey`
- [x] Create `groupKeyService.js` for Session Key generation/encryption
- [x] Implement `POST /api/groups/create` with password hashing
- [x] Implement `POST /api/groups/join` with password validation
- [x] Implement `POST /api/groups/:id/kick` with key rotation
- [x] Update `socketService.js` for group message broadcasting
- [x] Add `send_group_message` and `receive_group_message` socket events

### Frontend (Flutter + SQLite)
- [x] Create `Room` model
- [x] Create `RoomMember` model
- [x] Update `database_helper.dart` to v3 (add `rooms` and `room_members` tables)
- [ ] Create `GroupKeyService` for Session Key encryption/decryption
- [ ] Create `CreateGroupScreen` with password toggle
- [ ] Create `JoinGroupDialog` for password input
- [ ] Create `GroupListScreen` to display user's groups
- [ ] Create `GroupChatScreen` for group messaging
- [ ] Implement socket listeners for group events

### Testing
- [ ] Create test script to generate 10 test users
- [ ] Test create group with 5 members
- [ ] Test join group with password
- [ ] Test send/receive group messages
- [ ] Test kick member and key rotation
- [ ] Verify kicked member can't decrypt new messages

---

## üöÄ NEXT STEPS

1. **Implement GroupKeyService (Flutter)**
   - Session Key generation (32 random bytes)
   - RSA encryption with public key
   - RSA decryption with private key
   - Secure storage integration

2. **Build UI Screens**
   - CreateGroupScreen with password toggle
   - JoinGroupDialog with password input
   - GroupListScreen with room list
   - GroupChatScreen with message display

3. **Integrate Socket Events**
   - `join_group`, `leave_group`
   - `send_group_message`, `receive_group_message`
   - `session_key_rotated`, `member_joined`, `member_left`

4. **Test End-to-End**
   - Create group ‚Üí Join ‚Üí Send messages ‚Üí Kick member ‚Üí Verify security

---

**Created:** December 2025  
**Status:** Backend Complete ‚úÖ | Frontend In Progress üöß
